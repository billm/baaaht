// gateway.proto - gRPC service definitions for Gateway communication
//
// This file defines the GatewayService which provides session management,
// message handling, and streaming responses for user-facing communication
// with the orchestrator.
//
// Copyright 2026 baaaht project

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: proto/gateway.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GatewayService_CreateGatewaySession_FullMethodName = "/gateway.v1.GatewayService/CreateGatewaySession"
	GatewayService_GetGatewaySession_FullMethodName    = "/gateway.v1.GatewayService/GetGatewaySession"
	GatewayService_ListGatewaySessions_FullMethodName  = "/gateway.v1.GatewayService/ListGatewaySessions"
	GatewayService_CloseGatewaySession_FullMethodName  = "/gateway.v1.GatewayService/CloseGatewaySession"
	GatewayService_GatewaySendMessage_FullMethodName   = "/gateway.v1.GatewayService/GatewaySendMessage"
	GatewayService_StreamChat_FullMethodName           = "/gateway.v1.GatewayService/StreamChat"
	GatewayService_StreamResponses_FullMethodName      = "/gateway.v1.GatewayService/StreamResponses"
	GatewayService_SubscribeToEvents_FullMethodName    = "/gateway.v1.GatewayService/SubscribeToEvents"
	GatewayService_HealthCheck_FullMethodName          = "/gateway.v1.GatewayService/HealthCheck"
	GatewayService_GetStatus_FullMethodName            = "/gateway.v1.GatewayService/GetStatus"
)

// GatewayServiceClient is the client API for GatewayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GatewayService provides core gateway operations for user interaction
type GatewayServiceClient interface {
	// CreateGatewaySession creates a new gateway session for a user
	CreateGatewaySession(ctx context.Context, in *CreateGatewaySessionRequest, opts ...grpc.CallOption) (*CreateGatewaySessionResponse, error)
	// GetGatewaySession retrieves a gateway session by its ID
	GetGatewaySession(ctx context.Context, in *GetGatewaySessionRequest, opts ...grpc.CallOption) (*GetGatewaySessionResponse, error)
	// ListGatewaySessions retrieves all gateway sessions matching the specified filter
	ListGatewaySessions(ctx context.Context, in *ListGatewaySessionsRequest, opts ...grpc.CallOption) (*ListGatewaySessionsResponse, error)
	// CloseGatewaySession closes a gateway session
	CloseGatewaySession(ctx context.Context, in *CloseGatewaySessionRequest, opts ...grpc.CallOption) (*CloseGatewaySessionResponse, error)
	// GatewaySendMessage sends a message to a gateway session
	GatewaySendMessage(ctx context.Context, in *GatewaySendMessageRequest, opts ...grpc.CallOption) (*GatewaySendMessageResponse, error)
	// StreamChat establishes a bidirectional stream for real-time chat with response streaming
	StreamChat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamChatRequest, StreamChatResponse], error)
	// StreamResponses establishes a server-side stream for receiving response chunks
	StreamResponses(ctx context.Context, in *StreamResponsesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamResponsesResponse], error)
	// SubscribeToEvents subscribes to gateway events for a session
	SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GatewayEvent], error)
	// HealthCheck returns the health status of the gateway
	HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GatewayHealthCheckResponse, error)
	// GetStatus returns the current status of the gateway
	GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GatewayStatusResponse, error)
}

type gatewayServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayServiceClient(cc grpc.ClientConnInterface) GatewayServiceClient {
	return &gatewayServiceClient{cc}
}

func (c *gatewayServiceClient) CreateGatewaySession(ctx context.Context, in *CreateGatewaySessionRequest, opts ...grpc.CallOption) (*CreateGatewaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGatewaySessionResponse)
	err := c.cc.Invoke(ctx, GatewayService_CreateGatewaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GetGatewaySession(ctx context.Context, in *GetGatewaySessionRequest, opts ...grpc.CallOption) (*GetGatewaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGatewaySessionResponse)
	err := c.cc.Invoke(ctx, GatewayService_GetGatewaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) ListGatewaySessions(ctx context.Context, in *ListGatewaySessionsRequest, opts ...grpc.CallOption) (*ListGatewaySessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGatewaySessionsResponse)
	err := c.cc.Invoke(ctx, GatewayService_ListGatewaySessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) CloseGatewaySession(ctx context.Context, in *CloseGatewaySessionRequest, opts ...grpc.CallOption) (*CloseGatewaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseGatewaySessionResponse)
	err := c.cc.Invoke(ctx, GatewayService_CloseGatewaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GatewaySendMessage(ctx context.Context, in *GatewaySendMessageRequest, opts ...grpc.CallOption) (*GatewaySendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewaySendMessageResponse)
	err := c.cc.Invoke(ctx, GatewayService_GatewaySendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) StreamChat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamChatRequest, StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GatewayService_ServiceDesc.Streams[0], GatewayService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamChatRequest, StreamChatResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamChatClient = grpc.BidiStreamingClient[StreamChatRequest, StreamChatResponse]

func (c *gatewayServiceClient) StreamResponses(ctx context.Context, in *StreamResponsesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamResponsesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GatewayService_ServiceDesc.Streams[1], GatewayService_StreamResponses_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamResponsesRequest, StreamResponsesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamResponsesClient = grpc.ServerStreamingClient[StreamResponsesResponse]

func (c *gatewayServiceClient) SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GatewayEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GatewayService_ServiceDesc.Streams[2], GatewayService_SubscribeToEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToEventsRequest, GatewayEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_SubscribeToEventsClient = grpc.ServerStreamingClient[GatewayEvent]

func (c *gatewayServiceClient) HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GatewayHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewayHealthCheckResponse)
	err := c.cc.Invoke(ctx, GatewayService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayServiceClient) GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GatewayStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewayStatusResponse)
	err := c.cc.Invoke(ctx, GatewayService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServiceServer is the server API for GatewayService service.
// All implementations must embed UnimplementedGatewayServiceServer
// for forward compatibility.
//
// GatewayService provides core gateway operations for user interaction
type GatewayServiceServer interface {
	// CreateGatewaySession creates a new gateway session for a user
	CreateGatewaySession(context.Context, *CreateGatewaySessionRequest) (*CreateGatewaySessionResponse, error)
	// GetGatewaySession retrieves a gateway session by its ID
	GetGatewaySession(context.Context, *GetGatewaySessionRequest) (*GetGatewaySessionResponse, error)
	// ListGatewaySessions retrieves all gateway sessions matching the specified filter
	ListGatewaySessions(context.Context, *ListGatewaySessionsRequest) (*ListGatewaySessionsResponse, error)
	// CloseGatewaySession closes a gateway session
	CloseGatewaySession(context.Context, *CloseGatewaySessionRequest) (*CloseGatewaySessionResponse, error)
	// GatewaySendMessage sends a message to a gateway session
	GatewaySendMessage(context.Context, *GatewaySendMessageRequest) (*GatewaySendMessageResponse, error)
	// StreamChat establishes a bidirectional stream for real-time chat with response streaming
	StreamChat(grpc.BidiStreamingServer[StreamChatRequest, StreamChatResponse]) error
	// StreamResponses establishes a server-side stream for receiving response chunks
	StreamResponses(*StreamResponsesRequest, grpc.ServerStreamingServer[StreamResponsesResponse]) error
	// SubscribeToEvents subscribes to gateway events for a session
	SubscribeToEvents(*SubscribeToEventsRequest, grpc.ServerStreamingServer[GatewayEvent]) error
	// HealthCheck returns the health status of the gateway
	HealthCheck(context.Context, *emptypb.Empty) (*GatewayHealthCheckResponse, error)
	// GetStatus returns the current status of the gateway
	GetStatus(context.Context, *emptypb.Empty) (*GatewayStatusResponse, error)
	mustEmbedUnimplementedGatewayServiceServer()
}

// UnimplementedGatewayServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGatewayServiceServer struct{}

func (UnimplementedGatewayServiceServer) CreateGatewaySession(context.Context, *CreateGatewaySessionRequest) (*CreateGatewaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateGatewaySession not implemented")
}
func (UnimplementedGatewayServiceServer) GetGatewaySession(context.Context, *GetGatewaySessionRequest) (*GetGatewaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGatewaySession not implemented")
}
func (UnimplementedGatewayServiceServer) ListGatewaySessions(context.Context, *ListGatewaySessionsRequest) (*ListGatewaySessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGatewaySessions not implemented")
}
func (UnimplementedGatewayServiceServer) CloseGatewaySession(context.Context, *CloseGatewaySessionRequest) (*CloseGatewaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseGatewaySession not implemented")
}
func (UnimplementedGatewayServiceServer) GatewaySendMessage(context.Context, *GatewaySendMessageRequest) (*GatewaySendMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GatewaySendMessage not implemented")
}
func (UnimplementedGatewayServiceServer) StreamChat(grpc.BidiStreamingServer[StreamChatRequest, StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedGatewayServiceServer) StreamResponses(*StreamResponsesRequest, grpc.ServerStreamingServer[StreamResponsesResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamResponses not implemented")
}
func (UnimplementedGatewayServiceServer) SubscribeToEvents(*SubscribeToEventsRequest, grpc.ServerStreamingServer[GatewayEvent]) error {
	return status.Error(codes.Unimplemented, "method SubscribeToEvents not implemented")
}
func (UnimplementedGatewayServiceServer) HealthCheck(context.Context, *emptypb.Empty) (*GatewayHealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedGatewayServiceServer) GetStatus(context.Context, *emptypb.Empty) (*GatewayStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedGatewayServiceServer) mustEmbedUnimplementedGatewayServiceServer() {}
func (UnimplementedGatewayServiceServer) testEmbeddedByValue()                        {}

// UnsafeGatewayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServiceServer will
// result in compilation errors.
type UnsafeGatewayServiceServer interface {
	mustEmbedUnimplementedGatewayServiceServer()
}

func RegisterGatewayServiceServer(s grpc.ServiceRegistrar, srv GatewayServiceServer) {
	// If the following call panics, it indicates UnimplementedGatewayServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GatewayService_ServiceDesc, srv)
}

func _GatewayService_CreateGatewaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGatewaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).CreateGatewaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_CreateGatewaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).CreateGatewaySession(ctx, req.(*CreateGatewaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GetGatewaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGatewaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GetGatewaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GetGatewaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GetGatewaySession(ctx, req.(*GetGatewaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_ListGatewaySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGatewaySessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).ListGatewaySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_ListGatewaySessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).ListGatewaySessions(ctx, req.(*ListGatewaySessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_CloseGatewaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseGatewaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).CloseGatewaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_CloseGatewaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).CloseGatewaySession(ctx, req.(*CloseGatewaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GatewaySendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewaySendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GatewaySendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GatewaySendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GatewaySendMessage(ctx, req.(*GatewaySendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GatewayServiceServer).StreamChat(&grpc.GenericServerStream[StreamChatRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamChatServer = grpc.BidiStreamingServer[StreamChatRequest, StreamChatResponse]

func _GatewayService_StreamResponses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamResponsesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServiceServer).StreamResponses(m, &grpc.GenericServerStream[StreamResponsesRequest, StreamResponsesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_StreamResponsesServer = grpc.ServerStreamingServer[StreamResponsesResponse]

func _GatewayService_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServiceServer).SubscribeToEvents(m, &grpc.GenericServerStream[SubscribeToEventsRequest, GatewayEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GatewayService_SubscribeToEventsServer = grpc.ServerStreamingServer[GatewayEvent]

func _GatewayService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).HealthCheck(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GatewayService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GatewayService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServiceServer).GetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// GatewayService_ServiceDesc is the grpc.ServiceDesc for GatewayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GatewayService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gateway.v1.GatewayService",
	HandlerType: (*GatewayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGatewaySession",
			Handler:    _GatewayService_CreateGatewaySession_Handler,
		},
		{
			MethodName: "GetGatewaySession",
			Handler:    _GatewayService_GetGatewaySession_Handler,
		},
		{
			MethodName: "ListGatewaySessions",
			Handler:    _GatewayService_ListGatewaySessions_Handler,
		},
		{
			MethodName: "CloseGatewaySession",
			Handler:    _GatewayService_CloseGatewaySession_Handler,
		},
		{
			MethodName: "GatewaySendMessage",
			Handler:    _GatewayService_GatewaySendMessage_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _GatewayService_HealthCheck_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _GatewayService_GetStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChat",
			Handler:       _GatewayService_StreamChat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamResponses",
			Handler:       _GatewayService_StreamResponses_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _GatewayService_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/gateway.proto",
}
